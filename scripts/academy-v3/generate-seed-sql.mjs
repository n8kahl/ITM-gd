#!/usr/bin/env node

import { readFileSync, writeFileSync } from 'node:fs'
import path from 'node:path'

function parseArgs(argv) {
  const args = {
    input: 'docs/specs/academy-content/foundations-program.seed.json',
    output: 'supabase/seeds/academy_v3_foundations.sql',
  }

  for (let i = 0; i < argv.length; i += 1) {
    const token = argv[i]
    if (token === '--input' && argv[i + 1]) {
      args.input = argv[i + 1]
      i += 1
    } else if (token === '--output' && argv[i + 1]) {
      args.output = argv[i + 1]
      i += 1
    }
  }

  return args
}

function q(value) {
  const serialized = String(value)
  return `'${serialized.replace(/'/g, "''")}'`
}

function qJson(value) {
  return `${q(JSON.stringify(value))}::jsonb`
}

function qInt(value, fallback = 0) {
  const parsed = Number(value)
  if (!Number.isFinite(parsed)) return String(fallback)
  return String(Math.trunc(parsed))
}

function qNum(value, fallback = 1) {
  const parsed = Number(value)
  if (!Number.isFinite(parsed)) return String(fallback)
  return String(parsed)
}

function blockInstruction(blockType) {
  const instructions = {
    hook: 'Start with a concrete market moment and identify why it mattered.',
    concept_explanation: 'Explain the concept with one actionable decision rule.',
    worked_example: 'Walk through a realistic setup from context to decision.',
    guided_practice: 'Complete the guided prompt and compare your reasoning.',
    independent_practice: 'Solve the scenario independently before checking feedback.',
    reflection: 'Write what you would change next session and why.',
  }

  return instructions[blockType] || 'Complete this learning activity.'
}

const COMPETENCY_MAP = {
  market_context: {
    title: 'Market Context',
    description: 'Evaluate session structure and context before taking risk.',
    domain: 'analysis',
  },
  entry_validation: {
    title: 'Entry Validation',
    description: 'Confirm setup quality and invalidation before execution.',
    domain: 'execution',
  },
  position_sizing: {
    title: 'Position Sizing',
    description: 'Size trades from defined risk and invalidation distance.',
    domain: 'risk',
  },
  trade_management: {
    title: 'Trade Management',
    description: 'Manage live positions with predefined adaptation rules.',
    domain: 'execution',
  },
  exit_discipline: {
    title: 'Exit Discipline',
    description: 'Execute planned exits under pressure without drift.',
    domain: 'risk',
  },
  review_reflection: {
    title: 'Review Reflection',
    description: 'Use post-trade review to improve repeatability.',
    domain: 'improvement',
  },
}

function buildSql(seed) {
  const lines = []
  const allCompetencies = new Set()

  lines.push('-- Auto-generated by scripts/academy-v3/generate-seed-sql.mjs')
  lines.push('-- Source blueprint: docs/specs/academy-content/foundations-program.seed.json')
  lines.push('BEGIN;')
  lines.push('')

  const program = seed.program
  lines.push('-- Program')
  lines.push(`INSERT INTO academy_programs (code, title, description, is_active, metadata)`)
  lines.push(`VALUES (${q(program.code)}, ${q(program.title)}, ${q(program.description || '')}, true, '{}'::jsonb)`)
  lines.push('ON CONFLICT (code) DO UPDATE SET')
  lines.push('  title = EXCLUDED.title,')
  lines.push('  description = EXCLUDED.description,')
  lines.push('  is_active = EXCLUDED.is_active,')
  lines.push('  updated_at = now();')
  lines.push('')

  seed.tracks.forEach((track, trackIndex) => {
    const trackPosition = track.position ?? trackIndex + 1

    lines.push(`-- Track: ${track.code}`)
    lines.push('INSERT INTO academy_tracks (program_id, code, title, description, position, is_active, metadata)')
    lines.push('VALUES (')
    lines.push(`  (SELECT id FROM academy_programs WHERE code = ${q(program.code)}),`)
    lines.push(`  ${q(track.code)},`)
    lines.push(`  ${q(track.title)},`)
    lines.push(`  ${q(track.description || '')},`)
    lines.push(`  ${qInt(trackPosition)},`)
    lines.push("  true,")
    lines.push("  '{}'::jsonb")
    lines.push(')')
    lines.push('ON CONFLICT (program_id, code) DO UPDATE SET')
    lines.push('  title = EXCLUDED.title,')
    lines.push('  description = EXCLUDED.description,')
    lines.push('  position = EXCLUDED.position,')
    lines.push('  is_active = EXCLUDED.is_active,')
    lines.push('  updated_at = now();')
    lines.push('')

    track.modules.forEach((mod, moduleIndex) => {
      const modulePosition = mod.position ?? moduleIndex + 1
      const outcomes = Array.isArray(mod.learningOutcomes) ? mod.learningOutcomes : []

      lines.push(`-- Module: ${mod.slug}`)
      lines.push('INSERT INTO academy_modules (track_id, slug, code, title, description, learning_outcomes, estimated_minutes, position, is_published, metadata)')
      lines.push('VALUES (')
      lines.push(`  (SELECT t.id FROM academy_tracks t JOIN academy_programs p ON p.id = t.program_id WHERE p.code = ${q(program.code)} AND t.code = ${q(track.code)}),`)
      lines.push(`  ${q(mod.slug)},`)
      lines.push(`  ${q(mod.code)},`)
      lines.push(`  ${q(mod.title)},`)
      lines.push(`  ${q(mod.description || '')},`)
      lines.push(`  ${qJson(outcomes)},`)
      lines.push(`  ${qInt(mod.estimatedMinutes || 0)},`)
      lines.push(`  ${qInt(modulePosition)},`)
      lines.push('  true,')
      lines.push("  '{}'::jsonb")
      lines.push(')')
      lines.push('ON CONFLICT (slug) DO UPDATE SET')
      lines.push('  title = EXCLUDED.title,')
      lines.push('  description = EXCLUDED.description,')
      lines.push('  learning_outcomes = EXCLUDED.learning_outcomes,')
      lines.push('  estimated_minutes = EXCLUDED.estimated_minutes,')
      lines.push('  position = EXCLUDED.position,')
      lines.push('  is_published = EXCLUDED.is_published,')
      lines.push('  updated_at = now();')
      lines.push('')

      mod.lessons.forEach((lesson, lessonIndex) => {
        const lessonPosition = lesson.position ?? lessonIndex + 1
        const prereqSlugs = Array.isArray(lesson.prerequisiteLessonSlugs)
          ? lesson.prerequisiteLessonSlugs.filter((slug) => typeof slug === 'string' && slug.length > 0)
          : []

        const prereqExpression = prereqSlugs.length > 0
          ? `(SELECT COALESCE(array_agg(id), '{}'::uuid[]) FROM academy_lessons WHERE slug IN (${prereqSlugs.map((slug) => q(slug)).join(', ')}))`
          : "'{}'::uuid[]"

        lines.push(`-- Lesson: ${lesson.slug}`)
        lines.push('INSERT INTO academy_lessons (module_id, slug, title, learning_objective, estimated_minutes, difficulty, prerequisite_lesson_ids, position, is_published, metadata)')
        lines.push('VALUES (')
        lines.push(`  (SELECT id FROM academy_modules WHERE slug = ${q(mod.slug)}),`)
        lines.push(`  ${q(lesson.slug)},`)
        lines.push(`  ${q(lesson.title)},`)
        lines.push(`  ${q(lesson.learningObjective || '')},`)
        lines.push(`  ${qInt(lesson.estimatedMinutes || 0)},`)
        lines.push(`  ${q(lesson.difficulty || 'beginner')}::academy_difficulty,`)
        lines.push(`  ${prereqExpression},`)
        lines.push(`  ${qInt(lessonPosition)},`)
        lines.push('  true,')
        lines.push(`  ${qJson({ competenciesTargeted: lesson.competenciesTargeted || [] })}`)
        lines.push(')')
        lines.push('ON CONFLICT (slug) DO UPDATE SET')
        lines.push('  title = EXCLUDED.title,')
        lines.push('  learning_objective = EXCLUDED.learning_objective,')
        lines.push('  estimated_minutes = EXCLUDED.estimated_minutes,')
        lines.push('  difficulty = EXCLUDED.difficulty,')
        lines.push('  prerequisite_lesson_ids = EXCLUDED.prerequisite_lesson_ids,')
        lines.push('  position = EXCLUDED.position,')
        lines.push('  is_published = EXCLUDED.is_published,')
        lines.push('  metadata = EXCLUDED.metadata,')
        lines.push('  updated_at = now();')
        lines.push('')

        const blocks = Array.isArray(lesson.blocks) ? lesson.blocks : []
        blocks.forEach((block, blockIndex) => {
          const payload = {
            title: block.title || null,
            lessonTitle: lesson.title,
            lessonObjective: lesson.learningObjective || '',
            instruction: blockInstruction(block.blockType),
          }

          lines.push(`-- Block ${blockIndex + 1}: ${lesson.slug}`)
          lines.push('INSERT INTO academy_lesson_blocks (lesson_id, block_type, position, title, content_json)')
          lines.push('VALUES (')
          lines.push(`  (SELECT id FROM academy_lessons WHERE slug = ${q(lesson.slug)}),`)
          lines.push(`  ${q(block.blockType)}::academy_block_type,`)
          lines.push(`  ${qInt(block.position ?? blockIndex + 1)},`)
          lines.push(`  ${q(block.title || '')},`)
          lines.push(`  ${qJson(payload)}`)
          lines.push(')')
          lines.push('ON CONFLICT (lesson_id, position) DO UPDATE SET')
          lines.push('  block_type = EXCLUDED.block_type,')
          lines.push('  title = EXCLUDED.title,')
          lines.push('  content_json = EXCLUDED.content_json,')
          lines.push('  updated_at = now();')
          lines.push('')
        })

        const competencies = Array.isArray(lesson.competenciesTargeted)
          ? lesson.competenciesTargeted.filter((key) => typeof key === 'string' && key.length > 0)
          : []

        competencies.forEach((competencyKey) => {
          allCompetencies.add(competencyKey)
        })
      })

      const masteryTitle = `${mod.title} Mastery Check`
      lines.push(`-- Module summative assessment: ${mod.slug}`)
      lines.push('INSERT INTO academy_assessments (module_id, title, assessment_type, mastery_threshold, is_published, metadata)')
      lines.push('SELECT')
      lines.push(`  m.id, ${q(masteryTitle)}, 'summative'::academy_assessment_type, 0.75, true, '{}'::jsonb`)
      lines.push('FROM academy_modules m')
      lines.push(`WHERE m.slug = ${q(mod.slug)}`)
      lines.push('  AND NOT EXISTS (')
      lines.push('    SELECT 1 FROM academy_assessments a')
      lines.push('    WHERE a.module_id = m.id')
      lines.push(`      AND a.title = ${q(masteryTitle)}`)
      lines.push("      AND a.assessment_type = 'summative'::academy_assessment_type")
      lines.push('  );')
      lines.push('')
    })
  })

  if (allCompetencies.size > 0) {
    lines.push('-- Competencies')
    Array.from(allCompetencies)
      .sort()
      .forEach((key) => {
        const fallback = {
          title: key
            .split('_')
            .map((part) => part.slice(0, 1).toUpperCase() + part.slice(1))
            .join(' '),
          description: `Applied competency for ${key.replace(/_/g, ' ')}.`,
          domain: 'general',
        }
        const definition = COMPETENCY_MAP[key] || fallback

        lines.push('INSERT INTO academy_competencies (key, title, description, domain, metadata)')
        lines.push(`VALUES (${q(key)}, ${q(definition.title)}, ${q(definition.description)}, ${q(definition.domain)}, '{}'::jsonb)`)
        lines.push('ON CONFLICT (key) DO UPDATE SET')
        lines.push('  title = EXCLUDED.title,')
        lines.push('  description = EXCLUDED.description,')
        lines.push('  domain = EXCLUDED.domain,')
        lines.push('  updated_at = now();')
      })
    lines.push('')

    seed.tracks.forEach((track) => {
      track.modules.forEach((mod) => {
        mod.lessons.forEach((lesson) => {
          const competencies = Array.isArray(lesson.competenciesTargeted)
            ? lesson.competenciesTargeted.filter((key) => typeof key === 'string' && key.length > 0)
            : []

          competencies.forEach((competencyKey) => {
            lines.push('INSERT INTO academy_lesson_competencies (lesson_id, competency_id, weight)')
            lines.push('VALUES (')
            lines.push(`  (SELECT id FROM academy_lessons WHERE slug = ${q(lesson.slug)}),`)
            lines.push(`  (SELECT id FROM academy_competencies WHERE key = ${q(competencyKey)}),`)
            lines.push(`  ${qNum(1)}`)
            lines.push(')')
            lines.push('ON CONFLICT (lesson_id, competency_id) DO UPDATE SET')
            lines.push('  weight = EXCLUDED.weight;')
          })
        })
      })
    })
    lines.push('')
  }

  lines.push('COMMIT;')
  lines.push('')

  return lines.join('\n')
}

function main() {
  const args = parseArgs(process.argv.slice(2))
  const cwd = process.cwd()
  const inputPath = path.resolve(cwd, args.input)
  const outputPath = path.resolve(cwd, args.output)

  const payload = JSON.parse(readFileSync(inputPath, 'utf8'))
  const sql = buildSql(payload)
  writeFileSync(outputPath, sql, 'utf8')

  console.log(`Generated seed SQL: ${outputPath}`)
}

main()
